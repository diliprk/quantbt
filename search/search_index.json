{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Title","text":"<p>Hello world %% --- %% icon: material/home %% --- %% %% # Home %% %% QuantBT is a highly efficient backtesting library built with traders in mind. %% The core supports popular requirements of traders such as: %% %% 1. Live Trading   %% 2. Realistic real life scenarios %% %%     1. Place Stop loss and Take profit per trade %% %%     1. Moving stop to Break-even %%       %%     1. Adding a trailing stop loss %%    %%     1. Place simultaneous trades %%       %%     1. Trade time expiry %% %% Make sure to check out the tutorial for more! %% %% %% While the ideal audience is traders who like to use technical analysis, QuantBT can be used for other kind of scenarios.</p>"},{"location":"TODO/","title":"TODO","text":"<ul> <li>Futures Trading tutorial -- link to multiplier</li> </ul>"},{"location":"api/analysis/","title":"Analysis","text":""},{"location":"api/data/","title":"Data","text":""},{"location":"api/data/#_1","title":"Data","text":""},{"location":"api/data/#fetch-data-from-binance","title":"Fetch data from binance","text":"<p>QuantBT has a built in way of fetching data from </p>"},{"location":"api/data/#load-data-from-parquet-or-csv-files","title":"Load data from parquet or csv files","text":""},{"location":"api/enums/","title":"Enums","text":"<p>QuantBT relies on enums to streamline the namings. This is particularly useful when dealing with numba arrays.</p>"},{"location":"api/enums/#note-on-using-with-numba","title":"Note on using with numba","text":"<p>Numba does not recognize complex data times. While all QBT enums inherit <code>IntEnum</code>, their value must always be access using the <code>.value</code> property. For example:</p> <pre><code>trade_direction = OrderDirection.SHORT.value\n</code></pre>"},{"location":"api/enums/#orderdirection","title":"OrderDirection","text":"<pre><code>class OrderDirection(IntEnum):\n    SHORT = 0\n    LONG = 1\n</code></pre>"},{"location":"api/enums/#tradeclosereason","title":"TradeCloseReason","text":"<p>This object represents the reason a trade was closed. </p> <pre><code>class PositionCloseReason(IntEnum):\n    SIGNAL = 0          # An opposing signal was placed\n    SL = 1              # Stop Loss was hit\n    TP = 2              # Take Profit was hit\n    TIME_SL = 3         # Trade expired\n    TSL = 4             # Trailing stop loss was hit\n</code></pre>"},{"location":"api/enums/#trade","title":"Trade","text":"<p>This object represents a trade</p> <pre><code>class Trade(IntEnum):\n    IDX = 0               # Internally Used\n    Index = 1             # Index in the data OHLC\n    Direction = 2         # Trade Direction. look at [OrderDirection](/api/enums/#OrderDirection)\n    EntryTime = 3         \n    EntryPrice = 4\n    ExitTime = 5\n    ExitPrice = 6\n    Volume = 7\n    SL = 8                # Stop Loss\n    TSL = 9               # Trailing Stop Loss - if any\n    TP = 10               # Take Profit\n    TIME_SL = 11          # A time in the future at which the trade should be exited\n    PNL = 12              # Profit &amp; Loss of the trade\n    Commission = 13\n    Active = 14           # If the trade is still active, or it was closed already\n    CloseReason = 15      # Trade close reason. Look at [TradeCloseReason](/api/enums/#TradeCloseReason)\n    Extra = 16            # Any extra info provided\n</code></pre>"},{"location":"api/indicators/","title":"Indicators","text":""},{"location":"api/indicators/#cross-above","title":"Cross Above","text":"<p>This is a numba powered indicators that executed in parallel.</p>"},{"location":"api/optimisation/","title":"Optimisation","text":""},{"location":"api/performance/","title":"Performance","text":""},{"location":"api/signals-and-trades/","title":"Signals and Trades","text":""},{"location":"api/strategy/","title":"Base Strategy","text":"<p>The base strategy allows the construction of powerful portoflios based on different kind of signals. You can use it this way:</p> Usage exmple of Base Strategy<pre><code>from quantbt.strategies.S_base import S_base\n\nClass MyStrategy(S_base):\n    def generate_signals(self):\n      # Generate the signals needed\n\nst = MyStrategy(\n    data,\n    commission=1.2,\n    commission_type=CommissionType.FIXED,\n    multiplier=4,\n    data_type=DataType.OHLC,\n    initial_capital=100000,\n    default_trade_size=1,\n    trade_size_type=TradeSizeType.FIXED,\n)\n</code></pre> <p>PARAMETERS</p>"},{"location":"api/strategy/#commission","title":"Commission","text":"<p>QuantBT currently supports 2 type of commissions.</p>"},{"location":"api/strategy/#fixed","title":"Fixed:","text":"<p>Usage: <code>CommissionType.FIXED</code></p> <p>This is popular in CFD and Futures contracts where the broker charges a fixed amount. The amount if a flat fee added to each trade.  Please note that this is a one way fee, meaning that the resulting fee will be double this amount.</p>"},{"location":"api/strategy/#percentage","title":"Percentage:","text":"<p>Usage: <code>CommissionType.PERCENTAGE</code></p> <p>This is popular in crypto currencies where the commission is a percentage of volume traded. </p> Type Price Volume Fee Entry 10000 1 2$ Exit 12000 1 2.4$ <p>Total Commission is: 4.4$</p>"},{"location":"api/strategy/#tradesize","title":"TradeSize","text":"<p>QuantBT currently supports 2 type of trade sized.</p>"},{"location":"api/strategy/#fixed_1","title":"Fixed:","text":"<p>Usage: <code>TradeSize.FIXED</code></p> <p>This is popular in Futures contracts where the contrats have to be full numbers.</p>"},{"location":"api/strategy/#percentage_1","title":"Percentage:","text":"<p>Usage: <code>TradeSize.PERCENTAGE</code></p> <p>This is useful in crypto where you want the trade size to be a percentage of the total portfolio.</p>"},{"location":"api/strategy/#datatype","title":"DataType","text":"<p>In the quant world, there are generally 2 types of data.</p>"},{"location":"api/strategy/#bid-ask","title":"Bid Ask:","text":"<p>The most raw type is the Bid-Ask data. </p> <p>note: You can simulate a tick line chart, by setting bid and ask to the same value. Usage: <code>DataType.BID_ASK</code></p> <p>This is popular when scalping of doing HFT.</p>"},{"location":"api/strategy/#ohlc","title":"OHLC:","text":"<p>Usage: <code>DataType.OHLC</code></p> <p>The most common datatype from which you can build more diverse charts such as renko, range bars, etc...</p>"},{"location":"features/analysis/","title":"Analysis","text":""},{"location":"features/data/","title":"Data","text":""},{"location":"features/data/#_1","title":"Data","text":""},{"location":"features/data/#fetch-data-from-binance","title":"Fetch data from binance","text":"<p>QuantBT has a built in way of fetching data from </p>"},{"location":"features/data/#load-data-from-parquet-or-csv-files","title":"Load data from parquet or csv files","text":""},{"location":"features/indicators/","title":"Indicators","text":""},{"location":"features/live-trading/","title":"Live Trading","text":""},{"location":"features/optimisation/","title":"Optimisation","text":""},{"location":"features/performance/","title":"Performance","text":""},{"location":"features/signals-and-trades/","title":"Signals and Trades","text":""},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#install-quantbt","title":"Install QuantBT","text":""},{"location":"getting_started/installation/#using-poetry","title":"Using Poetry","text":"<p>It is highly recommend you use poetry to manage your virtual env</p> <pre><code>poetry add quantbt\n</code></pre>"},{"location":"getting_started/installation/#using-pip","title":"Using pip","text":"<p>If you wish to use pip, you can run the following:</p> <pre><code>pip install quantbt\n</code></pre>"},{"location":"getting_started/installation/#dependencies","title":"Dependencies","text":""},{"location":"getting_started/installation/#ta-lib","title":"Ta-Lib","text":"<p>Ta-Lib is a very powerful technical analysis library that is written in C, thus providing fantastic performance. Unfortunately, it needs to be installed seperatly on your system.</p> <p>Here's how</p>"},{"location":"getting_started/installation/#on-windows","title":"On Windows","text":"<p>Please follow the instructions here</p>"},{"location":"getting_started/installation/#on-mac","title":"On Mac","text":"<pre><code>brew install ta-lib\n</code></pre>"},{"location":"getting_started/installation/#on-linux","title":"On Linux","text":"<p>If you are on arch: <pre><code>yay -S ta-lib\n</code></pre></p> <p>For other distros, please read here</p>"},{"location":"getting_started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>Please refer to the docs for solution of any installation problems.</p>"},{"location":"getting_started/usage/","title":"Usage","text":""},{"location":"getting_started/usage/#notebook-and-source","title":"Notebook and Source","text":"<p>You can jump right into the Jupyter notebook here.</p>"},{"location":"getting_started/usage/#code","title":"Code","text":"<p>The following page will illustrate a very basic example where we will:</p> <ol> <li>Generate random OHLC data</li> <li>Generate a MA crossover signal </li> <li>Backtest the signal </li> <li>Plot the results</li> <li>Optimize the parameters</li> </ol>"},{"location":"getting_started/usage/#generate-random-ohlc-data","title":"Generate Random OHLC Data","text":"<p>There are multiple ways to generate data that will be used in your code, but for this example we will generate random data.</p> Generate random data<pre><code>import quantbt as qbt\n\ndata = qbt.data.random_data(100)[0] # (1)!\n</code></pre> <pre><code>                  open        high         low       close\ndate                                                      \n2023-01-01   97.029659   97.862781   95.676128   96.509250\n2023-01-02   96.509250   97.194830   92.974539   93.660119\n2023-01-03   93.660119   93.717696   91.819744   91.877321\n2023-01-04   91.877321   95.166148   90.110821   93.399648\n2023-01-05   93.399648   93.441865   91.959917   92.002133\n...                ...         ...         ...         ...\n2025-09-20  107.731634  107.845037  105.606316  105.719719\n2025-09-21  105.719719  107.410297  103.777499  105.468077\n2025-09-22  105.468077  106.318677  104.659829  105.510429\n2025-09-23  105.510429  106.464046  103.718701  104.672318\n2025-09-24  104.672318  104.681652  103.439853  103.449187\n\n[998 rows x 4 columns]\n</code></pre> <ol> <li>You do not have to use the seed, however setting one allows to have the same output every time you run the code.</li> </ol> <p>You can also read your own data files, or download binance data. More info here</p>"},{"location":"getting_started/usage/#generate-ma-cross-over-signals","title":"Generate MA cross over signals","text":"Generate signals<pre><code>import quantbt.indicators as ind # (1)!\nfrom quantbt.strategies.S_base import S_base\nfrom quantbt.core.enums import CommissionType, DataType, TradeSizeType\n\n\nclass MyStrategy(S_base):\n    def generate_signals(self):\n        short_period, long_period = params\n\n        self.sma_short = ind.talib_SMA(data.close, period=short_period)\n        self.sma_long = ind.talib_SMA(data.close, period=long_period)\n        self.long = ind.cross_above(self.sma_short, self.sma_long) # (2)!\n        self.short = ind.cross_below(self.sma_short, self.sma_long)\n\n        return {\n            \"long_entries\": self.long,\n            \"long_exits\": self.short,\n            \"short_entries\": self.short,\n            \"short_exits\": self.long,\n        }\n\nstrategy_settings = {\n    \"initial_capital\": 100_000, # (3)!\n    \"commission\": 1.2, # (4)!\n    \"commission_type\": CommissionType.FIXED, # (5)!\n    \"multiplier\": 20, # (6)\n    \"data_type\": DataType.OHLC, # (7)! \n    \"default_trade_size\": 1, # (8)!\n    \"trade_size_type\": TradeSizeType.FIXED, # (9)!\n}\n\nst = MyStrategy(data, **strategy_settings)\n</code></pre> <ol> <li>You can use talib indicators, or you can use some of our custom indicators</li> <li>We use the built in cross above indicator which is numba powered and parallelized.</li> <li>Define the initial capital. In USD</li> <li>Set the commission amount in USD to be paid. More info here</li> <li>Set the commission type. More info here</li> <li>Use the multiplier to reflect leverage. This example uses $NQ Futures, where each point is worth 20$</li> <li>Set the Datatype. There are 2 modes: OHLC and Tick. Read moe here</li> <li>This means that no matter what, the backtester will always only take 1 contract per trade</li> <li>2 Trade size types are supported: <code>Fixed</code> and <code>Percentage</code> . Read more here</li> </ol>"},{"location":"getting_started/usage/#backtest-signals","title":"Backtest signals","text":"Backtest signals<pre><code># We will be doing a 5-SMA and 23-SMA crossover\nparams = (5, 23)\nst.from_signals(params)\n</code></pre> <p>This will run the backtest using 5 and 23 as periods for the 2 moving averages</p>"},{"location":"getting_started/usage/#view-stats","title":"View Stats","text":"View Stats<pre><code>stats = st.get_stats()\nprint(stats)\n</code></pre> <pre><code>           End Value  ROI: (%)   DD  ratio\n(5, 23)  99618.40625     -0.38  0.5  -0.76\n</code></pre>"},{"location":"getting_started/usage/#view-trades","title":"View Trades","text":"View Trades<pre><code>trades = st.get_trades()\nprint(trades)\n</code></pre> <pre><code>     IDX  Index  Direction  EntryTime  EntryPrice  ...         PNL  Commission  Active  CloseReason  Extra\n0    0.0   24.0        0.0 2023-01-25   95.543045  ... -132.172492         2.4     0.0       SIGNAL   -1.0\n1    1.0   25.0        1.0 2023-01-26  102.031670  ...  -17.529395         2.4     0.0       SIGNAL   -1.0\n2    2.0   32.0        0.0 2023-02-02  101.275200  ...  -68.733008         2.4     0.0       SIGNAL   -1.0\n3    3.0   33.0        1.0 2023-02-03  104.591850  ...  317.843378         2.4     0.0       SIGNAL   -1.0\n4    4.0   90.0        0.0 2023-04-01  120.604019  ...    0.620630         2.4     0.0       SIGNAL   -1.0\n..   ...    ...        ...        ...         ...  ...         ...         ...     ...          ...    ...\n57  57.0  886.0        1.0 2025-06-05  108.097717  ...  133.575037         2.4     0.0       SIGNAL   -1.0\n58  58.0  916.0        0.0 2025-07-05  114.896469  ...   54.565790         2.4     0.0       SIGNAL   -1.0\n59  59.0  934.0        1.0 2025-07-23  112.048180  ... -139.441321         2.4     0.0       SIGNAL   -1.0\n60  60.0  937.0        0.0 2025-07-26  105.196114  ...  120.635431         2.4     0.0       SIGNAL   -1.0\n61  61.0  972.0        1.0 2025-08-30   99.044342  ...  110.159509         2.4     1.0          NaN   -1.0\n\n[62 rows x 17 columns]\n</code></pre>"},{"location":"getting_started/usage/#plot-equity","title":"Plot Equity","text":"Plot Equity<pre><code>st.plot_equity()\n</code></pre> Equity Plot"},{"location":"getting_started/usage/#plot-data-with-indicators-and-signals","title":"Plot Data with indicators and signals","text":"Plot results<pre><code>import matplotlib\n\nplotting = qbt.lib.plotting\nsubplots = [\n    plotting.add_line_plot(st.sma_short),\n    plotting.add_line_plot(st.sma_long),\n    plotting.add_markers(\n        st.long, data.close, color=\"green\", marker_type=matplotlib.markers.CARETUP\n    ),\n    plotting.add_markers(st.short, data.close, color=\"red\"),\n]\n\n\nqbt.lib.plotting.mpf_plot(data, subplots=subplots)\n</code></pre> Strategy with Indicators and signals"},{"location":"getting_started/usage/#advanced-plotting-using-ui","title":"Advanced Plotting using UI","text":"Plot results<pre><code>import pandas as pd\nfrom quantbt.lib import time_manip\nfrom quantbt.lib.data_to_csv import save_data, create_scatter_df\n\n\ndata[\"Date\"] = time_manip.convert_datetime_to_ms(data.index)\ntime_manip.convert_datetime_to_ms(data[\"Date\"])\n\n\"\"\"\nCreate the dataframes needed for the UI\n\"\"\"\ndf = pd.DataFrame(\n    {\n        \"date\": data[\"Date\"],\n        \"open\": data.open,\n        \"high\": data.high,\n        \"low\": data.low,\n        \"close\": data.close,\n        \"long\": st.long,\n        \"short\": st.short,\n        \"equity\": st.bt.data_module.equity,\n    }\n)\ndf.index = df[\"date\"]\n\nindicators_data = pd.DataFrame(\n    {\"ma1\": st.sma_long, \"ma2\": st.sma_short, \"equity\": st.bt.data_module.equity}\n)\n\n\"\"\"\nCreate the configuration that tells the UI which indicators to draw\n\"\"\"\nindicators = [\n    {\"name\": \"EMA Long\", \"type\": \"line\", \"panel\": 0, \"dataIndex\": 0},\n    {\"name\": \"MA Short\", \"type\": \"line\", \"color\": \"black\", \"panel\": 0, \"dataIndex\": 1},\n    {\"name\": \"Equity\", \"type\": \"line\", \"color\": \"black\", \"panel\": 1, \"dataIndex\": 2},\n]\n\n\n\"\"\"\nSave the data and config to the location of the UI\n\"\"\"\nUI_LOCATION = \"/home/alpha/workspace/cultivating-alpha/candles-ui/public\"\n\nsave_data(\n    UI_LOCATION, df, indicators, indicators_data, st.bt.trade_module.closed_trades\n)\n</code></pre> <p>You can view the output live here</p>"},{"location":"getting_started/usage/#optimize-the-parameters","title":"Optimize the parameters","text":"<p>TODO: WIP</p>"},{"location":"getting_started/usage/#all-in-one","title":"All in one","text":""},{"location":"getting_started/usage/#next-steps","title":"Next steps","text":"<p>QuantBT is much more than just a cross over signal tester.  It can create multiple trades, move stop to to Break-env, add a trailing Stop Loss and much more that you can find here</p> <p>On top of that, you can also deploy your backtested strategies straight into a live trading environment</p>"},{"location":"tutorials/signal_generation/","title":"Trade management","text":""},{"location":"tutorials/trade_management/","title":"Trade management","text":"<p>Hello world</p>"},{"location":"tutorials/trade_management/placing-sl-tp/","title":"Give trade a Sl and a TP","text":""},{"location":"tutorials/trade_management/simultaneous-trades/","title":"Simultaneous trades","text":""},{"location":"tutorials/trade_management/stop-to-be/","title":"Move stop to Break-Even","text":"<p>Risk management might tell you to move stop loss to break even when certain conditions are met. Doing so requires 2 simple steps:</p> <ol> <li>Create your custom Stop-To-BE function</li> <li>Pass that function to your strategy</li> </ol> <p>Find the full notebook here</p>"},{"location":"tutorials/trade_management/stop-to-be/#the-stop-to-be-function","title":"The Stop to BE function","text":"<p>The function will wait until a candle wicks above/below a long/short trade before moving the stop to break-env.</p> Create Stop to BE function<pre><code># Fill missing imports\nfrom numba import njit\nfrom quantbt.core.enums import Trade, OrderDirection\n\n\n\"\"\"\nThe function will be passed 3 variables by default:\n1. active_trades: A list of all the currently active trades (NOT orders)\n2. data: the original OHLC or tick by tick data you have passed to the strategy\n3. index: The index of the current tick iteration\n\"\"\"\n@njit(cache=True)\ndef stop_to_be_nb(active_trades, data, index):\n   current_low = data.low[index]\n   current_high = data.high[index]\n   for trade in active_trades: # (1)!\n        # Pass if we have already moved the SL to breakeven\n        if trade[Trade.EntryPrice.value] == trade[Trade.SL.value]: # (2)!\n            continue\n\n        entry_index = trade[Trade.Index.value] # (3)!\n        trade_entry_low = data.low[int(entry_index)] # (4)!\n        trade_entry_high = data.high[int(entry_index)]\n\n        direction = trade[Trade.Direction.value]\n\n        if direction == OrderDirection.SHORT.value:\n            if current_low &lt; trade_entry_low:\n                trade[Trade.SL.value] = trade[Trade.EntryPrice.value] # (5)!\n        else:\n            if current_high &gt; trade_entry_high:\n                trade[Trade.SL.value] = trade[Trade.EntryPrice.value]\n</code></pre> <ol> <li>The function will go over every trade one by one</li> <li>Look at the Trade Enum to see the different values it can take. Note that it is import to use <code>value</code> with numba functions</li> <li>We get the index at which the trade was entered</li> <li>We get the low/high at candle which triggered the trade</li> <li>The Stop loss value of the trade is updated. In real trading, this would lead to a new order to update the SL of the trade, if it's supported by the engine.</li> </ol>"},{"location":"tutorials/trade_management/stop-to-be/#using-the-function-with-the-strategy","title":"Using the function with the Strategy","text":"<p>In order to use the above function, simple pass it to the Base Strategy when you create it.</p> Passing Stop to BE function<pre><code>import quantbt as qbt\nimport quantbt.indicators as ind\nfrom quantbt.strategies.S_base import S_base\nfrom quantbt.core.enums import CommissionType, DataType, TradeSizeType\n\ndata = qbt.data.random_data(seed=300)[0]\n\n\nclass MyStrategy(S_base):\n    def generate_signals(self):\n        short_period, long_period = self.params\n\n        self.sma_short = ind.talib_SMA(data.close, period=short_period)\n        self.sma_long = ind.talib_SMA(data.close, period=long_period)\n        self.long = ind.cross_above(self.sma_short, self.sma_long)\n        self.short = ind.cross_below(self.sma_short, self.sma_long)\n\n        return {\n            \"long_entries\": self.long,\n            \"long_exits\": self.short,\n            \"short_entries\": self.short,\n            \"short_exits\": self.long,\n        }\n\n\nstrategy_settings = {\n    \"initial_capital\": 100_000,\n    \"commission\": 1.2,\n    \"commission_type\": CommissionType.FIXED,\n    \"multiplier\": 20,\n    \"data_type\": DataType.OHLC,\n    \"default_trade_size\": 1,\n    \"trade_size_type\": TradeSizeType.FIXED,\n}\n\n\nst_with_be = MyStrategy(data, stop_to_be=stop_to_be_nb, **strategy_settings) # (1)!\nparams = (5, 23)\nst.from_signals(params)\n</code></pre> <p>Make sure to pass the <code>stop_to_be_nb</code> created above to the strategy.</p>"},{"location":"tutorials/trade_management/stop-to-be/#results","title":"Results","text":"<p>Here are the result using the stop to BE on a simple MA crossover <pre><code>Stats without stop to BE:\n            End Value  ROI: (%)    DD     ratio\n(5, 23)  98809.007812     -1.19  1.92 -0.619792\n\nStats with stop to BE:\n            End Value  ROI: (%)    DD     ratio\n(5, 23)  99550.835938     -0.45  0.65 -0.692308\n</code></pre></p>"},{"location":"tutorials/trade_management/stop-to-be/#some-considerations","title":"Some considerations","text":"<p>The stop-to-be function has to be numba compiled, because it is passed to the numba compiled backtester. The only downside is that you will be required to recompile the function everytime you update the logic. This can be a pain during development. However, disabling numba can make that easier.</p>"},{"location":"tutorials/trade_management/trade-expiry/","title":"Trade expiry","text":""},{"location":"tutorials/trade_management/trailing-stop-loss/","title":"Add a trailing stop loss","text":"<p>A trailing stop loss (TSL) is activated once the trade is in profit. It can be used instead of a fixed take profit to let winner 'run'.</p> <p>In the world of QBT, a TSL is nothing but an indicator that is passed along with the strategy. It is computed once with the generated signals. You can pass both long and short TSL values.</p> <p>Find the full notebook here</p>"},{"location":"tutorials/trade_management/trailing-stop-loss/#the-tsl-calculation-function","title":"The TSL calculation function","text":"<p>If RSI crossed above 70, add the current low as a TSL for long trades only. If RSI crossed below 30, add the current high as a TSL for short trades only.</p> Calculate the TSL values<pre><code>import talib\nfrom numba import njit\nfrom quantbt.lib import np\n\n\n@njit\ndef calculate_trailing_exit(high, low, rsi):\n    trailing_long = np.full(len(high), 0, dtype=np.float64)\n    trailing_short = np.full(len(high), 0, dtype=np.float64)\n\n    for i in range(len(rsi)):\n        if rsi[i] &gt; 70 and rsi[i - 1] &lt; 70:\n            trailing_long[i] = low[i]\n        elif rsi[i] &lt; 30 and rsi[i - 1] &gt; 30:\n            trailing_short[i] = high[i]\n\n    return trailing_long, trailing_short\n</code></pre>"},{"location":"tutorials/trade_management/trailing-stop-loss/#using-the-function-with-the-strategy","title":"Using the function with the Strategy","text":"<p>In order to use the above function, simple pass it to the Base Strategy when you create it.</p> Adding the TSL to the strategy<pre><code>import quantbt as qbt\nimport quantbt.indicators as ind\nfrom quantbt.strategies.S_base import S_base\nfrom quantbt.core.enums import CommissionType, DataType, TradeSizeType\n\ndata = qbt.data.random_data(seed=300)[0]\n\n\nclass MyStrategy(S_base):\n    def generate_signals(self):\n        short_period, long_period = self.params\n\n        self.sma_short = ind.talib_SMA(data.close, period=short_period)\n        self.sma_long = ind.talib_SMA(data.close, period=long_period)\n        self.long = ind.cross_above(self.sma_short, self.sma_long)\n        self.short = ind.cross_below(self.sma_short, self.sma_long)\n\n        self.rsi = talib.RSI(data.close, timeperiod=14) # (1)!\n        self.trailing_sl_long, self.trailing_sl_short = calculate_trailing_exit(\n            data.high.values, data.low.values, self.rsi.values\n        )\n        return {\n            \"long_entries\": self.long,\n            \"long_exits\": self.short,\n            \"short_entries\": self.short,\n            \"short_exits\": self.long,\n            \"trailing_sl_long\": self.trailing_sl_long, # (2)!\n            \"trailing_sl_short\": self.trailing_sl_short, # (4)!\n        }\n\n\nstrategy_settings = {\n    \"initial_capital\": 100_000,\n    \"commission\": 1.2,\n    \"commission_type\": CommissionType.FIXED,\n    \"multiplier\": 20,\n    \"data_type\": DataType.OHLC,\n    \"default_trade_size\": 1,\n    \"trade_size_type\": TradeSizeType.FIXED,\n    \"use_trailing_sl\": True, # (3)\n}\n</code></pre> <ol> <li>Calculate the RSI using talib. Make sure it is installed</li> <li>Pass along the sl_long and sl_short to the <code>generate_signals</code> function</li> <li>By default, the strategy's <code>use_trailing_sl</code> is set to <code>False</code></li> <li>Pass along the short sl. Both long and short TSL are mandatory</li> </ol>"},{"location":"tutorials/trade_management/trailing-stop-loss/#results","title":"Results","text":"<p>Here are the result using the stop to BE on a simple MA crossover <pre><code>Stats without TSL:\n            End Value  ROI: (%)    DD     ratio\n(5, 23)  98809.007812     -1.19  1.92 -0.619792\n\nStats with TSL:\n            End Value  ROI: (%)   DD  ratio\n(5, 23)  98719.265625     -1.28  1.6   -0.8\n</code></pre></p>"}]}